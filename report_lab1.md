# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Иванов Д.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Левинская М.А. |              |               |


## Введение
В данной работе необходимо было ознакомиться с главными функциями для работы программирования на языке prolog: length, append, permute и др. Все предикаты - для работы со списками, все они пригодятся в дальнейших лабораторных, и на них строится алгоритм. 
## Задание: Реализовать предикаты обработки списка:
#### length/2

Рекурсивное определение длины списка, путем отсечения головы списка и увелечения счетчика длины на еденицу при каждой итерации предиката.
```prolog
myLength([], 0):-!.
myLength([_|L],N):-
	myLength(L,M), 
	N is M + 1.
```

#### member/2
Предикат проверяет принадлежность элемента списку. Принцип работы: постепенно отсекая голову списка - идет проверка на то, что голова совпадает с элементом, принадлежность которого мы проверяем.
```prolog
myMember(X,[X|_]):-!.
myMember(X,[_|L]):-
	myMember(X,L).
```
#### append/3
Предикат конкатенирует два списка. Принцип работы: сначала список L1 уменьшаем, создавая конец списка L3 в качестве L2, затем в голову добавляются элементы головы L1.
```prolog
myAppend([],L,L):-!.
myAppend([X|L1],L2,[X|L3]):-
	myAppend(L1,L2,L3).
```
#### Remove/3
Предикат Удаляет элемент из списка, выдавая новый. Принцип работы: сначала ищем элемент удаляемый элемент в списке, затем, при нахождении - создается конец списка нового как конец старого списка, который идет за удаляемым элементом. Потом рекурсивно копируем все элементы старого списка перед удаляемым в новый.
```prolog
myRemove(X,[X|T],T):-!.
myRemove(X,[Y|T],[Y|Z]):-
    myRemove(X,T,Z).
```
#### Permutation/2
Предикат получает новый список, перемешивая элементы старого. Принцип работы: С помощью функции selct мы получем список без элемента, а с помощью основного предиката - получаем конкатенацию этого списка с элементом. В результате получем различные комбинации списка.
```prolog
selct(X,[X|Xs],Xs).
selct(X,[Y|Xs],[Y|Zs]):-selct(X,Xs,Zs).

perm(L,[X|P]):-selct(X,L,L1),perm(L1,P).
perm([],[]).
```
#### mySublist/2
Предикат проверки вхождения списка в список. Принцип работы: ищется левая часть какого-то случайного разбиения списка на две части, проверяется, что S является его правым подсписком с помощью append. В результате получаем истину или ложь.
```prolog
mySublist(S, L):-
	myAppend(_, L1, L), 
	myAppend(S, _, L1).
```
#### myLastElement/2
Предикат получения последнего элемента списка. Принцип работы: отсекается голова списка, пока он длиной больше двух элементов. Затем этот последний элемент присваивается выходной переменной.
```prolog
myLastElement([S|[]], S):-!.
myLastElement([S|L], X):-
	myLastElement(L,Z),
	X is Z.
```
#### mySum/2
Предикат получения суммы элементов списка. Принцип работы: в результирующую переменную суммируются значения головы списка, пока список не пустой.
```prolog
mySum([], 0):-!.
mySum([S|L], X):-
	mySum(L, Y),
	X is Y + S.
```

## Выводы

Я считаю , что пролог - очень полезный язык для работы с символьными структурыми данных . Для написания программ на языках императивного типа понадобилось бы намного больше ненужной работы . Пролог же сам ищет данные. Аналогично пролог полезен для решения задач из первой части. 

При выполнении данной работы нужно было понять , как думает пролог , когда выполняет задачи . Для этого я нашел специально узнал про трассировку с помощью trace. Это очень помогает , так как самому прокрутить программу в поисках ошибки - трудно .