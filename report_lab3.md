## Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Иванов Д.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Поиски в пространстве состояний используются в разных задачах , и необходимо грамотно выбирать какой метод поиска оучше подойдет к данной задаче . Каждый поиск : в глубину , в ширину и с итерационным погружением имеет свои плюсы и минусы . Мы рассмотрим их в анализе программы и выводе . 

Плюс пролога при решении подобного рода задач заключается в том , что граф состояний , по которому происходит поиск генерируется программой , что позволяет поиску работать с графами неограниченного размера . В нашем случае вершины графа - состояния , а дуги - возможные переходы .


## Задание
Вдоль доски расположено 8 лунок, в которых лежат 4 черных и 3 белых шара.Передвинуть черные шары на место белых, а белые на место черных.Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром. При этом черные шары можно передвигать только вправо, а белые - только влево.

## Принцип решения

Для решение задачи я использовал метод поиска в глубину , ширину и с итеративным погружением.

Для начала необходимо было написать предикаты prolong/2 - продление пути и move/2 - поиск состояние , в которое можно перейти из данного состояния.

Они используеются во всех трех методах поисках 

```
% переход между состояниями

move(L,ResL):-
    length(L,Len),
    Len1 is Len - 1,
    between(0,Len1,A),
    B is A + 1,
    check_correct(L,A,B),
    swap_elem(L,A,B,X),

    ResL = X.

% продление пути без зацикливания
prolong([X|T],[Y,X|T]):-
    move(X,Y),
    \+ member(Y,[X|T]).
```
Далее я написал алгоритм поиска в глубину:
```
% поиск в глубину
search_dpth(A,B):-
    write('DFS START'), nl,
    dpth([A],B,L),
    inv_print(L).

dpth([X|T],X,[X|T]).
dpth(P,F,L):-
    prolong(P,P1),
    dpth(P1,F,L).
```
Поиск с итеративным погружением : 
```
search_id(Start,Finish):-
    write('ITER START'), nl,
    int(DepthLimit),
    depth_id([Start],Finish,Res,DepthLimit),
    inv_print(Res).

depth_id([Finish|T],Finish,[Finish|T],0).
depth_id(Path,Finish,R,N):-
    N @> 0,
    prolong(Path,NewPath),
    N1 is N - 1,
    depth_id(NewPath,Finish,R,N1).

search_id(Start,Finish,Path):-
    int(Level),
    search_id(Start,Finish,Path,Level).
```

На последнем этапе я написал алгоритм поиска в ширину :
```prolog
% поиск в ширину
search_bdth(X,Y):-
    write('BFS START'), nl,
    bdth([[X]],Y,L),
    inv_print(L).

bdth([[X|T]|_],X,[X|T]).
bdth([P|QI],X,R):-
    findall(Z,prolong(P,Z),T),
    append(QI,T,Q0),
    bdth(Q0,X,R).

bdth([_|T],Y,L):-
    bdth(T,Y,L).
```

К сожалению , при поиске в ширину переполняется стек , о чем говорит то , что длина очереди достигает 1700 списков. 
Поиск в глубину оказался не самым медленным, но он находит самый длинный путь . В отличие от него поиск с итеративным погрудением показал хорошие результаты , он нашел один из самых коротких решений. Но при этом он дольше ищет , потому что путь решения оказался длиной 16 , что говорит о том , что все погружения с глубиной < 16 оказались неуспешными и это заняло много ресурсов . О поиске в ширину я вообще промолчу. В данной задачи он абсолютно проигрывает . 

## Выводы

С поисками , изученными при выполнении данной лабораторной я встречался и раньше , поэтому было интересно реализовать их на прологе. Благодаря спискам , код становится довольно небольшим .
Если мы знаем , что между начальным и конечным состоянием небольшое число переходов , то целесообразно использовать поиск в ширину . Если использовать поиск в глубину , то поиск может легко зациклится или бесконечно продлевать путь , даже если решение есть , поэтому и придуман поиск с итеративным погружением.Ну и понятно , что поиск в ширину не выгоден , если цель находится далеко , потому что у нас очередь путей будет расти в геометрической прогрессии.
