# Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Иванов Д.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Под обработкой естественных языков (Natural Language Processing, NLP) понимается создание систем, обрабатывающих или “понимающих” язык с целью выполнения определенных задач. Теоретически, построение естественно-языкового интерфейса для компьютеров — очень привлекательная цель. 

Понимание естественного языка иногда считают AI-полной задачей, потому как распознавание живого языка требует огромных знаний системы об окружающем мире и возможности с ним взаимодействовать. Само определение смысла слова «понимать» — одна из главных задач искусственного интеллекта.

Традиционный подход к пониманию естественных языков предполагал глубокое знание предметной области – лингвистики. Понимание таких терминов, как фонемы и морфемы, было обязательным, так как существуют целые дисциплины лингвистики, посвященные их изучению. Именно основываясь на лингвистическом разборе предложения я собираюсь найти решение задачи.

Благодаря тому, что лингвистика во многом строится на совокупности формальных правилах, использовать лингвистические методы к распознованию естественногшо языка в Прологе оказывается очень удобно, ввиду его декларативности. Этим я и воспользуюсь при решении этой задачи.


## Задание

Цель работы: Познакомиться на практике с методами анализа естественно-языковых
текстов в системах логического программирования (Пролог, Mecury), реализовать в
соответствии с вариантом задания несложный фрагмент естественного-языкового
интерфейса к модельной задаче и протестировать его на ряде примеров.
1. Генеалогическое дерево задано фактами вида
```
parent(alexei,tolia).
parent(alexei,volodia).
parent(tolia,tima).
...

```

Написать программу на Прологе, запросы к которой будут выглядеть следующим
образом:
```
Запросы:
?- answer([volodia, brat , toli, ‘?’],X).
?- answer([kto, tolin, brat, ‘?’],X).
?- answer([chei, brat, volodia, ‘?’],X).
Результаты: X=yes, X=volodia, X=tolia.

```

## Принцип решения

Для воспроизведения естественного языкового интерфейса мы задаем нашему предикату anwser/2 в качестве аргумента список- разложение искомого запроса на атомы. В результате подбирается описание anwser/2 с шаблоном, который соответствует входным данным, на основе которых производятся необходимые вычисления.

```
parent(alexey, tolya).
parent(alexey, volodya).
parent(tolya, tima).
parent(gena, sergey).
parent(gena, alexey).
parent(gena, oleg).
parent(oleg, misha).


padej(tolya, toli, tolin).
padej(alexey, alexeya, alexeev).
padej(tima, timi, timin).
padej(volodya, volodi, volodin).
padej(gena, geni, genin).
padej(oleg, olega, olegov).
padej(misha, mishi, mishin).
padej(sergey, sergeya, sergeev).

quest_first(A) :- member(A, ['Kto', kto]).
quest_second(A) :- member(A, [chei, 'Chei']).

% kto brat toli?
answer([A, B, C, '?'], Ans):-
	quest_first(A),
	move(B, _, _),
	padej(X, C, Y),
	(parent(X, _);parent(_, X)),
	findall(Q, move(B, Q, X), Ans),!.

% Chei brat volodya?
	answer([A, B, X, '?'], Ans):-
	quest_second(A),
	move(B, _, _),
	padej(X, C, _),
	(parent(X, _); parent(_, X)),
	findall(Q, (move(B, X, U), padej(U, Q, _)), Ans),!.

% volodya brat toli?
answer([A, B, C, '?'], Ans):-
	(parent(A, _); parent(_, A)),
	move(B, _, _),
	padej(X, C, _),
	move(B, A, X), !.
  
```

Здесь предикат move/3 описывает родство близких родственников(дед, отец, сын)

```
move(equal, X, X).
move(brat, X, Y) :- parent(Moth, X), parent(Moth, Y), not(move(equal, X, Y)).
move(papa, X, Y) :- parent(X, Y).
move(son, X, Y) :- parent(Y,X).
move(ded, X, Y) :- parent(X, W), parent(W, Y).

```
Для работы со склонениями имен я ввел предикат padej/3, в котором 1-ый аргумент- имениетельный падеж, 2-ой - родительный, а 3-ий отвечет на вопрос "чей?".

По итогу результатом выполнения предиката будет множество решенй - ответов на вопрос, задаваемый в естественной форме в соответсвующем падеже.

## Результаты

```
?- anwser([tolya, papa, timi, '?'], Y).
true.

?- anwser([kto, ded, toli, '?'], Y).
Y = [gena].

?- anwser([chei, brat, alexey, '?'], Y).
Y = [sergeya, olega].

?- anwser([chei, papa, gena, '?'], Y).
Y = [sergeya, alexeya, olega].

```

## Выводы

В результате решения задачи распознования естественного языка и работы с ним, мне не раз приходилось задуматься, что это огромная и перспективная отрасль информационных технологий, которая постоянно развивается.

При решении задачи было заметно, что составленных предикатов недостаточно полноценного приближения к естественному языку, и следует постоянно увеличивать базу с шаблонами вопросов и ответов для общения с пользователем.

Также трудно было не заметить, что составление такой программы обработки и дальнейшая ее модернизация в разы проще, чем на императивных языках, так как в Прологе достаточно просто добавить очередное правило проверки списка для увеличения способности общения нашей программы.

В процессе решения данная лабораторная работа увлекла меня в мир задач искуственного после того, как я увидел результат проделанной мной работы. Ведь способность общения с программой на прямую, будто с человеком изъявляя свои мысли и желания воображает воображение, особенно когда обращаешь внимание на простоту реализации данного интерфейса.

